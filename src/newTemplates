#define PIXEL_DOMAIN_CHECK(T){if(T>255)T=255;else if (T<0)T=0;}

template<typename T>
  T Filters<T>::saturation(float sValue,
		 	   T& pixelR,
			   T& pixelG,
 		           T& pixelB,
			   T& pixelOutputR,
			   T& pixelOutputG, 
		           T& pixelOutputB) 
  {
    /***Filter can be implemented inplace.***/
    //sValue can be between -1 and 1.
    //1 means no change. 0 signifies black & white. 2 signifies max saturation.
    sValue=sValue/100;
    float temp;
    float bwValue=pixelR*0.33+pixelG*0.33+pixelB*0.33;
    
    ///Adjust Saturation of Every Channel    
    if(pixelR>bwValue)temp=pixelR+(pixelR-bwValue)*sValue;  
    else temp=pixelR-(pixelR-bwValue)*sValue;
    PIXEL_DOMAIN_CHECK(temp);    
    pixelOutputR=temp;

    if(pixelG>bwValue)temp=pixelG+(pixelG-bwValue)*sValue;           
    else temp=pixelG-(pixelG-bwValue)*sValue;
    PIXEL_DOMAIN_CHECK(temp);
    pixelOutputG=temp;
  
    if(pixelB>bwValBue)temp=pixelB+(pixelB-bwValue)*sValue;           
    else temp=pixel-(pixelB-bwValue)*sValue;
    PIXEL_DOMAIN_CHECK(temp);
    pixelOutputB=temp;  
  }

template<typename T>
void Filters<T>::NormalizePixel(float whitePoint,
			     float blackPoint,
			     float outputWhitePoint,
		             float outputBlackPoint,
			     T& pixel, 
                             T& pixelOutput)
{
    /***Filter can be implemented inplace.***/
    //Values for both all the input values can be between 0-255;
    //DEFAULT VALUES:
    //BLACK POINT:0   WHITE POINT:255   OUTPUT WHITE POINT:255 OUTPUT BLACK POINT:0
    //can be used to perform histogram normalization.
} 

template<typename T>
void Filters<T>::ApplyFunctionOnPixel(float *curveFunction,
				   T& pixel,
				   T& pixelOutput)
{
    /***Filter can be implemented inplace. ***/
    ///Curve function defines the the output values from 0-255 got after Spline fitting
    ///input points
    pixelOuput=curveFunction[pixel];

}

template<typename T>
void Filters<T>::GetBW(T &pixelR,
		    T &pixelG,
                    T &pixelB,
                    T &pixelOutputR,
                    T& pixelOutputG,
                    T& pixelOutputB)
{
  /***Filter can be implemented inplace ***/
  ///BW filter is basically 0.6*R + 0.35*G + 0.5*B
   float value=0.6pixelR+0.35*pixelG+0.5pixelB;
  pixelOutputR=pixelOutputG=pixelOutputB=value;
}

template<typename T>
void Filters<T>::GetSepia(T &pixelR, 
			  T &pixelG,
			  T &pixelB,
			  T &pixelOutputR,
			  T &pixelOutputG,
                          T &pixelOutputB)
{
  /***Filter can be implemented inplace ***/
  ///BW filter is basically 0.6*R + 0.35*G + 0.5*B
  ///Sepia we basically add some in RedChannel, and siginficantly less in Green Channel
  float value=0.6pixelR+0.35*pixelG+0.5*pixelB;
  pixelOutputR=pixelOutputG=pixelOutputB=value;
  pixelOutputR*=1.4;
  pixelOuptutG*=1.1;
}


